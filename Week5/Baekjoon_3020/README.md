# 개똥벌레

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 128 MB | 15699 | 6767 | 4969 | 44.212% |

## 문제

개똥벌레 한 마리가 장애물(석순과 종유석)로 가득찬 동굴에 들어갔다. 동굴의 길이는 N미터이고, 높이는 H미터이다. (N은 짝수) 첫 번째 장애물은 항상 석순이고, 그 다음에는 종유석과 석순이 번갈아가면서 등장한다.

아래 그림은 길이가 14미터이고 높이가 5미터인 동굴이다. (예제 그림)

https://upload.acmicpc.net/c6fd496d-ccf5-4f9d-a06e-32b121fc6a82/-/preview/

이 개똥벌레는 장애물을 피하지 않는다. 자신이 지나갈 구간을 정한 다음 일직선으로 지나가면서 만나는 모든 장애물을 파괴한다.

위의 그림에서 4번째 구간으로 개똥벌레가 날아간다면 파괴해야하는 장애물의 수는 총 여덟개이다. (4번째 구간은 길이가 3인 석순과 길이가 4인 석순의 중간지점을 말한다)

https://upload.acmicpc.net/bfcbb94f-0e15-4ff9-b2ef-43e07c7ee503/-/preview/

하지만, 첫 번째 구간이나 다섯 번째 구간으로 날아간다면 개똥벌레는 장애물 일곱개만 파괴하면 된다.

동굴의 크기와 높이, 모든 장애물의 크기가 주어진다. 이때, 개똥벌레가 파괴해야하는 장애물의 최솟값과 그러한 구간이 총 몇 개 있는지 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N과 H가 주어진다. N은 항상 짝수이다. (2 ≤ N ≤ 200,000, 2 ≤ H ≤ 500,000)

다음 N개 줄에는 장애물의 크기가 순서대로 주어진다. 장애물의 크기는 H보다 작은 양수이다.

## 출력

첫째 줄에 개똥벌레가 파괴해야 하는 장애물의 최솟값과 그러한 구간의 수를 공백으로 구분하여 출력한다.

---

### 문제 풀이

- 알고리즘 분류에 ‘이분탐색’, ‘누적합’이라고 되어있었다. 이분탐색에 좀 더 집중하고 이분탐색 풀이법에 맞게 풀려 했더니 도저히 풀리지가 않더라..
- 이분탐색보단 누적합에 더 집중해서 풀어야 하는 문제이다. 누적합 문제나 마찬가지인 것 같다.

```python
from sys import stdin

N, H = map(int, stdin.readline().split())
obstacle = [0]*(H+1)
top = [0]*(H+1)
bottom = [0]*(H+1)
# top, bottom 배열은 각각 해당 인덱스의 높이에 몇 개의 장애물이 존재하는지 저장한다.

for i in range(N):
    height = int(stdin.readline())
    if i%2==0:
        bottom[height]+=1
    else :
        top[H-height+1]+=1
# print(top, bottom)

for i in range(2,H+1):
    top[i] += top[i-1] 
for i in range(H-1, 0, -1):
    bottom[i] += bottom[i+1]
for i in range(H+1):
    obstacle[i] = top[i]+bottom[i]
# print(top, bottom)
obstacle.pop(0)
# print(obstacle)
print(min(obstacle),obstacle.count(min(obstacle)))
```

- top, bottom 변수가 중요하게 쓰인다.
    - top은 종유석, bottom은 석순의 개수를 센다. 각 인덱스는 그 인덱스의 높이를 가진 종유석, 석순의 개수를 의미한다.
- **누적합이 사용되는 부분 :**
    - 처음엔 인덱스 높이에 해당하는 종유석, 석순의 의미를 가지는 변수였다면, 이젠 누적합을 계산해주면 **각 인덱스를 지날 때 부딪히는 장애물의 개수**를 의미하게 된다.
    - top의 경우 아래를 향해 자라나고, 위로 갈 수록 부딪히는 개수가 많으므로 1 부터 시작하여 H까지 위를 향하며 누적합을 계산해준다.(bottom의 경우 아래로 누적합 계산)
- top과 bottom를 같은 인덱스끼리 더해주면 인덱스만큼의 높이를 지날 때 부딪히는 종유석, 석순의 총 개수가 된다. 이 값을 obstacle 변수에 저장해준다.
- 이후로는 obstacle 변수에서 최소값을 구하고, 이 값이 몇 개 존재하는지 찾으면 문제는 풀린다.

- 이분탐색을 사용한 부분은 아무데도 없는거같다.. 최소값을 구하고 그 값의 개수를 구하는 부분에서 사용되는 거였을까?
- [참고](https://hyeo-noo.tistory.com/310)
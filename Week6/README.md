# 이코테 강의 06.

# 다이나믹 프로그래밍(동적 계획법)

- 메모리를 적절히 사용하여 수행시간 효율성을 비약적으로 향상
- **이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장**하여 다시 계산하지 않도록 한다
- 탑다운과 보텀업 방식이 있다.
- 다음 조건
    - **최적 부분 구조(Optimal Substructure)**
        
        : 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다.
        
    - **중복되는 부분 문제(Overlapping Subproblem)**
        
        : 동일한 작은 문제를 반복적으로 해결
        

### 피보나치 수열

> 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 . . .
> 
- 점화식: 인점한 상들 사이의 관계식
- 피보나치 수열의 점화식:
    - $a_n = a_{n-1} +a_{n-2}$
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bfd1607a-85d5-4334-a1ed-85e9fe466018/Untitled.png)
    
- 단순 재귀함수를 활용할 경우:

```python
def fibo(x):
		if x==1 or x==2:
				return 1
		return fibo(x-1) fibo(x-2)
print(fibo(6))
```

- 해당 코드는 **지수 시간 복잡도**를 가지게 된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/99824f50-74cf-4364-9919-eca5598541f2/Untitled.png)

- 다음과 같이 f(2)가 여러번 호출되며 중복되는 문제가 발생한다. 한 번 해결한 문제에 대한 정보를 메모리에 별도로 기록해주어야 한다(**메모이제이션**)

- 위와 같은 문제의 효율적인 해법:**다이나믹 프로그래밍**
    - **최적 부분 구조**와 **중복되는 부분** 문제를 가지므로 사용 조건 또한 만족한다.

### 메모이제이션(Memoization)

: 한 번 계산한 결과를 메모리 공간에 메모하는 기법

- 탑다운(**하향식**) 방식이다.
- 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
- **캐싱(Caching)이라고도 한다.**

- 탑다운 방식의 피보나치수열

```python
d = [0]*100

def fibo(x):
    if x==1 or x==2:
        return 1
    if d[x] !=0:
        return d[x]
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

print(fibo(99))
```

위와 같은 방법을 사용할 경우 시간 복잡도는 $O(n)$이다.

- 보텀업 방식의 피보나치 수열

```python
d = [0]*100

d[1] = 1
d[2] = 1 
n=99
for i in range(3, n+1):
    d[i] = d[i-1]+d[i-2]
    
print(d[n])
```

- 다이나믹 프로그래밍과 분할정복
    - 모두 최적 부분 구조를 가질 때 사용할 수 있다.
    - 차이점은 **부분 문제의 중복**이 있느냐 이다.
        - 다이나믹 프로그래밍의 경우 부분 문제가 중복된다.

### 다이나믹 프로그래밍 접근법

- 주어진 문제가 다이나믹 프로그래밍 유형임을 파악
- 그리디, 구현, 완전탐색 등의 아이디어로 해결할 수 있는지 검토한다.
    - 다른 방법이 떠오르지 않는다면 다이나믹 프밍을 고려해본다.
- 재귀 함수의 비효율적 완전 탐색 프로그램을 작성한 뒤(탑다운) 작은 문제에서 구한 답이 큰 문제에서 사용될 수 있으면, 코드를 개선해본다.
- **일반 코테에서는 기본 유형의 다이나믹 프밍 문제가 출제되는 경우가 많다**

### 문제

**개미전사**

- 문제 설명:
    - 개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를 몰래 공격하려고 한다. 메뚜기 마을에는 여러 개의 식량창고가 있는데 식량창고는 일직선으로 이어져 있다.
    - 각 식량창고에는 정해진 수의 식량을 저장하고 있으며 개미 전사는 식량창로를 선택적으로 약탈하여 식량을 빼앗을 예정이다. 이때 메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 있다.
    - 따라서 개미 전사가 정찰병에게 들키지 않고 식량창고를 약탈하기 위해서는 최소한 한 칸 이상 떨어진 식량창고를 약탈해야 한다.
- 문제 조건
    - 난이도: ★★☆ | 풀이시간 30분 | 시간 제한 1초 | 메모리 제한 128MB
    - 입력 조건:
        - 첫째 줄에 식량창고의 개수 N이 주어진다. (3≤ N ≤ 100)
        - 둘째 줄에 공백을 기준으로 각 식량창고에 저장된 식량의 개수 K가 주어진다. (0≤K≤1000)
    - 출력 조건:
        - 첫째 줄에 개미 전사가 얻을 수 있는 식량의 최댓값을 출력하라.
    - 입력 예시
        
        ```
        4
        1 3 1 5
        ```
        
    - 출력 예시
        
        ```
        8
        ```
        

- 문제 해결 아이디어
    - 왼쪽부터 차례대로 식량창고를 턴다고 했을 떄, 특정한 i번째 식량 창고에 대해서 털지 안 털지의 여부를 결정하면, 2가지 경우 중에서 더 많은 식량을 털 수 있는 경우를 선택하면 된다.
    - $a_i$  = i번째 식량창고까지의 최적의 해(얻을 수 있는 식량의 최댓값)
    - $k_i$ = i번째 식량 창고에 있는 식량의 양
    - 점화식 :
        - $a_i = max(a_{i-1}, a_{i-2}+k_i)$
    - 한 칸 이상 떨어진 식량창고는 항상 털 수 있으므로 (i-3)번째 이하는 고려할 필요가 없다.
    
    ```python
    n = int(input())
    
    array = list(map(int, input().split()))
    
    d = [0]*100
    
    d[0] = array[0]
    d[1] = max(array[0], array[1])
    
    for i in range(2, n):
        d[i] = max(d[i-1], d[i-2]+array[i])
        
    print(d[n-1])
    ```
    

**1로 만들기**

- 문제 설명
    - 정수 X가 주어졌을 때, 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지 이다.
        1. X가 5로 나누어 떨어지면, 5로 나눈다
        2. X가 3으로 나누어 떨어지면, 3으로 나눈다
        3. X가 2로 나누어 떨어지면, 2로 나눈다.
        4. X에서 1을 뺀다
    - 정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 값을 1로 만들고자 한다. 연산을 사용하는 횟수의 최솟값을 출력하라. 예를 들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값이다.
        - 26 → 25 → 5 → 1
- 문제 조건:
    - 풀이 시간 20분 | 시간제한 1초 | 메모리 제한 128MB
    - 입력 조건
        - 첫째 줄에 정수 X가 주어진다. (1≤X≤30,000)
    - 출력 조건
        - 첫째 줄에 연산하는 횟수의 최솟값 출력
    - 입력 예시
        
        ```python
        26
        ```
        
    - 출력 예시
        
        ```python
        3
        ```
        
- 문제 해결:
    - $a_i = i$를 1로 만들기 위한 최소 연산 횟수
    - 점화식:
        - $a_i = min(a_{i-1}, a_{i/2}, a_{i/3}, a_{i/5}) +1$
    
    ```python
    x = int(input())
    
    d = [0]*30001
    
    for i in range(2, x+1):
        d[i] = d[i-1]+1
        if i%2 == 0:
            d[i] = min(d[i], d[i//2]+1)
        if i%3 == 0:
            d[i] = min(d[i], d[i//3]+1)
        if i%5 == 0:
            d[i] = min(d[i], d[i//5]+1)
    print(d[x])
    ```
    

**효율적인 화폐 구성**

- 문제 설명
    - N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다. 이때 각 종류의 화폐는 몇 개라도 사용할 수 있다.
    - M원을 만들기 위한 최소한의 화폐 개수를 출력하는 프로그램을 작성하라.
- 문제 조건
    - 풀이시간 30분 | 시간제한 1초 | 메모리 제한 128MB
    - 입력 조건
        - 첫째 줄에 N, M이 주어진다 (1≤N≤100, 1≤M≤10,000)
        - 이후의 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐의 가치는 10,000보다 작거나 같은 자연수 이다.
    - 출력 조건
        - 첫째 ㅈㄹ에 최소 화폐 개수를 출력한다.
        - 불가능할 때는 -1을 출력한다
    - 입력예시
        
        ```python
        2 15
        2
        3
        ```
        
    - 출력 예시
        
        ```python
        5
        ```
        
- 문제 해결
    - $a_i$ = 금액 i를 만들 수 있는 최소한의 화폐개수
    - $k$ = 각 화폐의 단위
    - 점화식:
        - $a_{i-k}$를 만드는 방법이 존재하는 경우, $a_i = min(a_i, a_{i-k}+1)$
        - 존재하지 않는 경우 $a_i = INF$